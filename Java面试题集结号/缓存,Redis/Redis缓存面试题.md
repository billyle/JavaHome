### 缓存/Redis
1.  Redis用过哪些数据类型，每种数据类型的使用场景
    答：Redis常用的数据类型包括：
    *   **字符串（String）**：存储简单的键值对，如用户会话信息、计数器、共享状态等。
    *   **哈希（Hash）**：存储对象，如用户信息（用户ID为键，用户名、年龄等为字段和值），适合结构化数据存储。
    *   **列表（List）**：存储有序的字符串集合，如消息队列、微博时间线、排行榜（简单版）。
    *   **集合（Set）**：存储无序且不重复的字符串，如标签系统、共同好友、抽奖活动（去重）。
    *   **有序集合（Sorted Set）**：存储不重复字符串，且每个元素关联一个分数，如排行榜、带权重的任务队列。
2.  Redis缓存穿透、缓存雪崩和缓存击穿原因，以及解决方案
    答：
    *   **缓存穿透**：原因：大量请求查询不存在的数据，缓存不命中，请求全部打到数据库。解决方案：接口层增加校验，如ID必须大于0；缓存空对象（设置较短的TTL）；布隆过滤器（Bloom Filter）。
    *   **缓存雪崩**：原因：大量缓存Key同时失效，或者Redis服务宕机，导致大量请求涌入数据库。解决方案：设置不同的TTL时间；使用Redis集群提高可用性；服务降级；限流。
    *   **缓存击穿**：原因：某个热点Key突然失效，大量请求同时访问该Key，导致数据库压力骤增。解决方案：互斥锁（保证只有一个请求去查库并更新缓存）；逻辑过期（缓存中存储逻辑过期时间，后台线程异步更新）；永不过期（不设置TTL，但需要额外机制感知数据变更）。
3.  如何使用Redis来实现分布式锁，redis分布式锁有什么缺陷？
    答：使用Redis实现分布式锁通常使用`SET key value NX PX milliseconds`命令。获取锁的流程：SET一个唯一值（如UUID）作为value，设置NX（不存在才设置）和PX（设置过期时间）。释放锁：通过Lua脚本判断value是否为当前线程设置的值，是则执行DEL。
    缺陷：
    *   **网络抖动**：可能导致锁无法获取或释放。
    *   **主从切换**：如果Redis是主从架构，主节点刚设置锁就宕机，从节点提升为主，锁会丢失。
    *   **锁过期时间设置**：设置过短可能导致业务未完成锁就过期；设置过长可能导致持有锁的进程崩溃后锁无法释放。
    *   **不可重入**：默认实现不支持同一线程多次获取同一把锁。
    *   **锁无法被延长**：如果持有锁的进程处理时间超过TTL，锁会自动释放，其他进程可能获取到锁，导致数据不一致。
4.  Redis 持久化机制，有几种方式，优缺点是什么，怎么实现的，RDB和AOF的区别
    答：Redis主要有两种持久化机制：RDB（Redis Database）和AOF（Append Only File）。
    *   **RDB**：
        *   优点：生成单一文件，适合备份和迁移；恢复速度快；对性能影响较小（只在保存点时阻塞）。
        *   缺点：数据有丢失风险（取决于保存间隔）；保存时可能产生fork耗时。
        *   实现：通过`SAVE`（阻塞式）或`BGSAVE`（后台fork子进程）命令，将内存中的数据集快照保存到磁盘的`.rdb`文件中。可以配置保存策略（如`save 900 1`表示900秒内有1个键变化则触发）。
    *   **AOF**：
        *   优点：数据更安全，丢失数据量可控（秒级或更少）；支持Append模式，追加写性能较好。
        *   缺点：文件体积通常比RDB大；恢复速度比RDB慢；对性能有一定影响（需要写入磁盘）。
        *   实现：记录所有写命令到AOF文件末尾。可以通过`appendfsync`配置同步频率（always/everysec/no）。支持AOF重写（`BGREWRITEAOF`），压缩AOF文件大小。
    *   **区别**：RDB是快照，AOF是命令日志；RDB恢复快但可能丢失数据，AOF安全但恢复慢且文件大；通常建议两者结合使用。
5.  Redis集群，高可用，原理。
    答：Redis集群通过数据分片（Sharding）和主从复制（Replication）实现高可用和横向扩展。
    *   **原理**：将整个数据集划分为多个槽（Slot，共16384个），每个节点负责一部分槽。客户端通过哈希算法（如CRC16）计算Key对应的槽，然后路由到负责该槽的节点。每个槽由一个主节点（Master）负责，并可以有一个或多个从节点（Slave）进行数据复制。当主节点故障时，哨兵（Sentinel）或集群自身会自动将从节点提升为主节点，保证服务不中断。
    *   **高可用**：依赖于主从复制和故障转移机制。哨兵模式（Redis Sentinel）是早期常用方案，负责监控、通知和自动故障转移。Redis Cluster 3.0+ 内置了部分高可用功能（节点故障检测和主从切换）。
6.  Redis的数据淘汰策略
    答：Redis提供了多种数据淘汰策略，当内存不足时决定如何淘汰数据：
    *   **noeviction**：默认策略，不淘汰任何数据，写入失败（返回OOM错误）。
    *   **volatile-ttl**：在设置了过期时间的键中，淘汰TTL最短的键。
    *   **volatile-random**：在设置了过期时间的键中，随机淘汰。
    *   **volatile-lru**：在设置了过期时间的键中，使用LRU（最近最少使用）算法淘汰。
    *   **volatile-lfu**：在设置了过期时间的键中，使用LFU（最不经常使用）算法淘汰。
    *   **allkeys-lru**：在所有键中，使用LRU算法淘汰。
    *   **allkeys-random**：在所有键中，随机淘汰。
    *   **allkeys-lfu**：在所有键中，使用LFU算法淘汰。
7.  为什么要用redis？为什么要用缓存，在哪些场景使用缓存
    答：
    *   **为什么要用Redis**：因为Redis是高性能的内存数据库，支持多种数据结构，具备持久化能力，支持发布/订阅、事务等，且部署简单，社区活跃。它特别适合需要快速读写、结构化数据存储、分布式锁等场景。
    *   **为什么要用缓存**：缓存用于存储热点数据，减少对后端数据库（如MySQL）的访问压力，提高系统响应速度和吞吐量，改善用户体验。
    *   **使用场景**：会话缓存（Session Cache）、商品信息缓存、用户信息缓存、排行榜、计数器、分布式锁、消息队列、缓存数据库查询结果等。
8.  redis事务，了解吗，了解Redis事务的CAS操作吗
    答：了解。Redis事务通过`MULTI`、`EXEC`、`DISCARD`、`WATCH`命令实现。
    *   `MULTI`开始一个事务块，后续命令会排队。
    *   `EXEC`执行事务块中所有排队命令。
    *   `DISCARD`取消事务块，放弃所有排队命令。
    *   `WATCH`用于监视一个或多个键，如果在`EXEC`执行前这些键被其他客户端修改，则事务会失败（返回空结果）。这类似于CAS（Compare-And-Swap）操作，确保在执行事务期间，被监视的键没有被修改，提供一定的原子性和一致性保证。
9.  如何解决 Redis 的并发竞争Key问题。
    答：可以通过以下方式解决：
    *   **分布式锁**：使用Redis的SET NX PX命令获取锁，确保同一时间只有一个线程能操作该Key，操作完成后释放锁。
    *   **消息队列/任务队列**：将需要竞争Key的操作放入队列，由消费者顺序处理，避免并发。
    *   **使用Redis事务（WATCH）**：监视Key，如果Key在事务执行前被修改，则重试或放弃。
    *   **版本号控制**：在Key的值中包含版本号，更新时检查版本号是否匹配。
10. Redis为什么是单线程的，为什么单线程还这么快？
    答：
    *   **为什么是单线程**：Redis的网络I/O和键值操作（核心逻辑）主要由一个线程处理，主要是为了简化开发、减少多线程竞争（锁）带来的性能损耗，以及保证命令的原子性。虽然后续版本引入了多线程用于部分耗时操作（如RDB/AOF重写），但核心事件循环和命令处理仍是单线程。
    *   **为什么快**：
        *   **纯内存操作**：数据存储在内存中，读写速度极快。
        *   **高效的数据结构**：针对不同场景优化了数据结构（如哈希表、跳跃表、整数集合等）。
        *   **I/O多路复用**：使用epoll（Linux）、kqueue（BSD/macOS）等机制，单线程可以高效处理大量并发连接的网络I/O。
        *   **非阻塞I/O**：网络I/O是异步的，不会阻塞主线程处理其他命令。
11. 如何保证缓存与数据库双写时的数据一致性?
    答：这是一个复杂的问题，没有绝对完美的方案，通常采用以下策略组合：
    *   **先更新数据库，再更新缓存**：这是常见做法。但如果缓存更新失败，会导致不一致。可以通过重试机制解决。
    *   **先删除缓存，再更新数据库**：适用于读多写少场景。更新数据库后立即删除缓存，下次读请求会去数据库加载新数据并回填缓存。但存在窗口期不一致问题（旧数据可能在缓存中）。
    *   **延时双删**：先删除缓存，再更新数据库，然后延时一段时间（如1秒）再删除一次缓存，确保在窗口期内加载到旧数据的请求被拦截。
    *   **数据库触发器**：在数据库更新时触发一个操作去更新/删除缓存，但耦合度高，不易维护。
    *   **消息队列（MQ）**：数据库更新后发送消息到MQ，消费者监听MQ并更新/删除缓存。可以实现最终一致性，但引入了新的复杂度。
    *   **业务逻辑控制**：在业务层面保证，如在一个事务中完成数据库更新和缓存更新/删除。
12. redis和memcached有什么区别
    答：
    *   **数据类型**：Redis支持多种数据结构（String, Hash, List, Set, Sorted Set等），Memcached只支持简单的Key-Value字符串。
    *   **持久化**：Redis支持RDB和AOF持久化，Memcached默认不持久化（除非使用第三方插件）。
    *   **内存管理**：Redis使用更复杂的内存管理方式（如ziplist、intset等压缩结构），Memcached使用预分配的内存池。
    *   **分布式**：Redis有内置的集群支持（Redis Cluster），Memcached需要客户端或代理（如Twemproxy）实现分布式。
    *   **单线程 vs 多线程**：Redis核心是单线程（但网络I/O是多线程的），Memcached是多线程的。
    *   **功能丰富度**：Redis功能更丰富，支持事务、发布/订阅、Lua脚本等，Memcached相对简单。
13. JVM本地缓存，了解过吗
    答：了解。JVM本地缓存是指直接在Java应用程序的JVM内存中存储数据的缓存，不依赖外部服务。常见的实现有：
    *   **Caffeine**：高性能的Java缓存库，基于窗口LRU/W-TinyLFU算法，是目前推荐使用的。
    *   **Guava Cache**：Google Guava库提供的缓存实现，功能稳定，使用广泛。
    *   **Ehcache**：功能强大的缓存框架，支持本地缓存和分布式缓存。
    *   **ConcurrentHashMap**：最简单的实现，但需要手动处理过期、淘汰等逻辑。
    它们通常提供自动加载、过期策略、大小限制、并发控制等功能。
14. redis的list结构相关的操作。
    答：Redis的List（列表）是基于双向链表（或压缩列表）实现的，主要操作包括：
    *   **LPUSH / RPUSH**：在列表头部/尾部添加一个或多个元素。
    *   **LPOP / RPOP**：移除并返回列表头部/尾部的第一个元素（模拟栈/队列）。
    *   **LRANGE**：获取列表指定范围内的元素。
    *   **LLEN**：获取列表长度。
    *   **LINDEX**：获取列表指定索引位置的元素。
    *   **LREM**：移除列表中指定数量的等于某个值的元素。
    *   **LSET**：设置列表指定索引位置的元素值。
    *   **LTRIM**：修剪列表，只保留指定范围内的元素。
    *   **BLPOP / BRPOP**：阻塞式弹出，当列表为空时阻塞，直到有元素可弹出或超时（常用于实现阻塞队列）。
    *   **RPOPLPUSH / BRPOPLPUSH**：原子性地从源列表弹出尾部元素并推入目标列表头部（常用于实现工作窃取）。
15. redis2和redis3的区别，redis3内部通讯机制。
    答：
    *   **Redis 2 vs Redis 3**：
        *   Redis 3.0引入了Redis Cluster，实现了内置的自动分片和故障转移，这是最核心的区别。
        *   Redis 3.0对性能和稳定性进行了优化。
        *   引入了`CONFIG REWRITE`命令，优化配置文件的生成。
        *   增加了一些新命令和功能。
    *   **Redis 3内部通讯机制（集群）**：
        集群节点之间通过TCP通信，使用一种称为“Gossip”的协议来交换信息，主要包括：
        *   **节点发现**：新节点通过 handshake 机制加入集群，并从其他节点获取集群成员信息。
        *   **状态同步**：节点定期向其他节点发送ping消息，包含自己的状态和一些随机节点信息，接收方回复pong。通过这种方式传播节点的状态（在线、下线、疑似下线等）。
        *   **故障检测**：如果节点没有收到某个节点的pong响应，会标记为疑似下线（PFAIL），然后通过Gossip消息传播，当多数主节点都认为某个主节点疑似下线时，会标记为下线（FAIL），并开始故障转移流程。
        *   **消息类型**：包括meet（握手）、ping、pong、fail（故障通知）、ping-ack等。
16. Redis的选举算法和流程是怎样的？
    答：Redis的选举（主节点选举）发生在主节点故障，其从节点需要提升为主节点时。选举流程主要由哨兵（Sentinel）或Redis Cluster自身控制：
    *   **发现故障**：哨兵或集群节点检测到主节点故障。
    *   **发起选举**：故障主节点的从节点会参与选举。
    *   **选举条件**：通常选择优先级最高、数据最新（复制偏移量最大）、runid最小的从节点。
    *   **投票**：在哨兵模式下，由达到法定票数的哨兵投票决定新的主节点。在Redis Cluster中，由集群内多数主节点投票决定。
    *   **提升主节点**：获得足够票数的从节点被提升为主节点，并通知其他从节点更新配置。
    *   **通知客户端**：新的主节点和哨兵/集群会通知客户端更新连接地址。
17. Reids的主从复制机制原理。
    答：Redis主从复制（Replication）原理：
    1.  **建立连接**：从节点向主节点发送`SYNC`命令（在旧版）或`PSYNC`命令（在新版，支持部分重同步）。
    2.  **全量同步**：主节点收到`SYNC`或`PSYNC`（无偏移量）后，执行以下步骤：
        *   执行`BGSAVE`生成RDB快照文件。
        *   将所有缓存的写命令（AOF缓冲区）发送给从节点。
        *   RDB文件生成后，通过网络发送给从节点。
        *   从节点接收RDB文件并加载到内存，然后接收并执行缓存的写命令。
    3.  **部分同步**（`PSYNC`支持）：如果从节点能提供有效的复制偏移量和run id，主节点会检查自己的缓冲区，如果存在对应偏移量的命令，则只发送这部分增量数据给从节点，避免全量同步。
    4.  **命令传播**：全量/部分同步完成后，主节点会将后续发生的所有写命令实时异步地发送给从节点，保证数据一致性。
    5.  **从节点角色**：从节点默认不对外服务，只读。可以通过配置让其可写，但数据最终以主节点为准。
18. Redis的线程模型是什么？
    答：Redis的核心线程模型是**单线程事件循环模型**。主线程负责：
    *   **事件循环**：使用I/O多路复用机制（如epoll）监听多个socket的事件（连接、可读、可写）。
    *   **命令处理**：当socket可读时，主线程读取客户端请求，解析命令，并在内存中执行命令（如更新键值）。
    *   **网络写入**：当socket可写时，主线程将命令执行结果写入socket发送给客户端。
    虽然核心是单线程，但Redis 4.0+ 引入了多线程来处理一些耗时的后台任务，如`BGREWRITEAOF`和`BGSAVE`，以减轻主线程负担，提高性能。
19. Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。
    答：
    *   **注意事项**：
        *   合理设置Key的过期时间，避免内存无限增长。
        *   避免使用`KEYS *`等命令阻塞服务，使用`SCAN`代替。
        *   大Key、热Key问题要关注，避免影响性能。
        *   正确配置持久化，平衡数据安全性和性能。
        *   监控Redis实例状态（内存、CPU、连接数、延迟等）。
    *   **持久化方式**：见问题4。RDB适合备份，AOF适合数据安全。通常两者结合。
    *   **内存设置**：通过`maxmemory`设置最大使用内存，通过`maxmemory-policy`设置淘汰策略。根据应用场景选择合适的单位（MB、GB等）。
    *   **集群应用**：
        *   **应用**：解决单机内存瓶颈，实现高可用和横向扩展。
        *   **优势**：支持更大规模数据，高可用性（自动故障转移），读写性能可扩展（分片）。
        *   **劣势**：客户端实现复杂（需要处理槽分配、重定向等），不支持跨节点事务，某些命令（如`KEYS`）在集群中受限或需要特殊处理，运维相对复杂。
    *   **淘汰策略**：见问题6。根据数据访问模式和重要性选择，如读多写少用`allkeys-lru`，有明确冷热数据区分用`volatile-lru`。
20. Redis缓存分片
    答：Redis缓存分片（Sharding）是指将缓存数据分散存储到多个Redis实例中，目的是突破单机内存限制，提高缓存容量和并发处理能力。常见的分片策略有：
    *   **客户端分片**：在客户端代码中实现分片逻辑，如使用一致性哈希（Consistent Hashing）将Key映射到特定实例。优点是简单直接，缺点是客户端代码复杂，扩展性差。
    *   **代理分片**：使用一个中间代理层（如Twemproxy、Codis）接收所有请求，代理根据分片规则将请求转发到正确的Redis实例。优点是客户端透明，缺点是引入了单点故障和性能瓶颈。
    *   **服务端分片**：Redis Cluster就是典型的服务端分片，将数据划分为16384个槽，每个节点负责一部分槽。客户端（如Lettuce、Jedis的集群模式）需要知道槽的分布，或者由服务端（MOVED/ASK重定向）告知。这是目前主流的方案。
21. redis的集群怎么同步的数据的？
    答：Redis集群的数据同步是通过**主从复制（Replication）**机制实现的。集群中的每个数据分片（Slot）由一个主节点（Master）负责，并可以配置一个或多个从节点（Slave）。主节点将数据的变更（写命令）通过命令传播的方式实时异步地发送给其所有的从节点，从节点接收并执行这些命令，从而保持与主节点的数据一致。当主节点故障时，其从节点会被提升为主节点，并通过复制机制从其他主节点（或其从节点）同步数据，最终达到数据一致。
22. 请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。
    答：可以设计一个基于`Caffeine`或`Guava Cache`的本地缓存，并添加自适应控制逻辑：
    *   **基础缓存**：使用Caffeine，设置一个初始的最大大小（如`maximumSize`）。
    *   **监控机制**：定期（如每分钟）检查当前缓存的实际大小（元素数量或估算内存占用）。
    *   **自适应调整**：
        *   **扩容**：如果缓存大小接近上限，但命中率仍然很高，可以适当增加`maximumSize`（如增加10%）。
        *   **缩容**：如果缓存大小接近上限，且命中率下降，可以减少`maximumSize`（如减少10%）。或者，如果系统整体内存紧张，可以强制减少`maximumSize`。
    *   **淘汰策略**：始终启用高效的淘汰策略（如`evictionPolicy`设置为LRU或LFU）。
    *   **加载策略**：对于频繁访问但未缓存的数据，实现自动加载逻辑。
    *   **实现**：可以通过扩展Caffeine的`Cache`或`LoadingCache`，或者封装一层，在put/get操作和定期任务中实现上述逻辑。
23. redis的哨兵模式，一个key值如何在redis集群中找到存储在哪里。
    答：
    *   **哨兵模式**：哨兵（Sentinel）本身不直接提供数据分片功能。它主要负责监控Redis主从节点的健康状态，在主节点故障时自动进行故障转移（Failover），选举新的主节点，并通知客户端更新连接信息。客户端需要自己实现或者依赖客户端库来实现连接逻辑。
    *   **在哨兵模式下找Key位置**：客户端通常连接到哨兵实例，哨兵会返回当前可用的主节点地址。客户端连接到主节点后，如果应用了Redis Cluster的分片逻辑（如一致性哈希），客户端会根据Key计算应该去哪个节点（在哨兵模式下，通常就是主节点，除非Key在从节点上）。如果没有分片逻辑，客户端默认连接的主节点就是访问的节点（简单主从，所有写和部分读都在主节点）。
24. Redis，一个字符串类型的值能存储最大容量是多少？
    答：Redis字符串类型的值最大可以存储 **512MB** 的数据。
25. MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
    答：可以通过以下几种策略结合保证Redis中存储的是热点数据：
    *   **基于访问频率**：记录每个Key的访问次数，定期（如每小时）将访问次数最高的N个Key（这里是20w个）加载到Redis中。
    *   **基于LRU/LFU算法**：在Redis中设置`allkeys-lru`或`allkeys-lfu`淘汰策略，并设置`maxmemory`为适当大小。这样，当有新数据需要缓存时，会自动淘汰掉最近最少使用或最不频繁使用的旧数据，确保缓存中始终是最近最常访问的热点数据。
    *   **机器学习预测**：利用历史访问数据训练模型，预测未来的热点数据，提前加载到Redis。
    *   **组合策略**：例如，结合LRU和访问频率，优先缓存访问频率高且近期被访问过的数据。
26. Redis和Redisson有什么关系？
    答：Redis 是一个开源的、内存中的数据结构存储系统，可以用作数据库、缓存和消息中间件。它本身提供了一套命令行接口（CLI）和简单的客户端库（如 Jedis、Lettuce 等）供开发者使用。
    Redisson 是 Redis 的一个 Java 客户端实现，但它不仅仅是一个简单的客户端。它是由 Redis Labs 开发的，提供了更高级的抽象和功能。Redisson 封装了 Redis 的底层操作，提供了一套丰富且易于使用的 Java API，支持多种 Redis 数据结构，并内置了许多高级功能，例如：
    - 分布式锁（RedissonLock）
    - 读写锁（RedissonReadWriteLock）
    - 信号量（RedissonSemaphore）
    - 可过期锁（RedissonRedLock）
    - 分布式集合（如分布式 Set、Map、List 等）
    - 分布式对象（如分布式 Queue、Stack 等）
    - 支持多种序列化方式
    - 提供了异步和反应式（Reactive）API
      简单来说，Redis 是底层数据存储服务，而 Redisson 是一个功能强大的 Java 客户端库，简化了与 Redis 的交互，并提供了许多开箱即用的分布式解决方案。
27. Redis中的管道有什么用？
    答：Redis 管道（Pipeline）是一种客户端技术，允许客户端将多个 Redis 命令一次性发送给服务器，而不需要等待每个命令的响应。服务器会顺序处理这些命令，并将所有响应打包返回给客户端。
    管道的主要作用是：
    - **提高性能**：减少了客户端和服务器之间的网络往返次数（Round-Trip Time, RTT）。对于需要执行大量连续命令的场景，可以显著提升吞吐量。
    - **批量处理**：将多个操作捆绑在一起执行，逻辑上更清晰。
      例如，原本需要 10 次网络往返的 10 个命令，使用管道后可能只需要 1 次网络往返（发送所有命令）和 1 次网络往返（接收所有响应），大大减少了网络开销。
28. Redis事务相关的命令有哪几个？
    答：Redis 的事务主要通过以下命令实现：
    - `MULTI`：标记一个事务块的开始。在 `MULTI` 命令之后发送的命令不会立即执行，而是被放入一个队列中。
    - `EXEC`：执行 `MULTI` 命令之后队列中所有的命令。如果事务执行成功，所有命令都会按顺序执行；如果事务执行失败（例如某个命令语法错误），则整个事务块会被取消（discard）。
    - `DISCARD`：取消当前正在执行的事务，清空事务队列。
    - `WATCH`：监视一个或多个 key。如果在 `EXEC` 执行之前，被监视的 key 被其他客户端修改了，那么当前事务会以失败告终（返回空值）。常用于实现乐观锁。
    - `UNWATCH`：取消对所有 key 的监视。
29. Redis key的过期时间和永久有效分别怎么设置？
    答：
    - 设置 key 的过期时间：
        - `EXPIRE key seconds`：为指定的 key 设置生存时间（TTL），单位是秒。例如 `EXPIRE mykey 10` 表示 mykey 10 秒后过期。
        - `PEXPIRE key milliseconds`：同上，但单位是毫秒。
        - `EXPIREAT key timestamp`：为 key 设置过期时间戳（Unix 时间戳，单位是秒）。例如 `EXPIREAT mykey 1712345678` 表示在指定时间戳对应的时刻过期。
        - `PEXPIREAT key milliseconds-timestamp`：同上，但时间戳单位是毫秒。
        - `SET key value EX seconds` (Redis 2.6+) 或 `SET key value PX milliseconds`：在设置 key 值的同时，直接指定过期时间。例如 `SET mykey "hello" EX 10`。
    - 设置 key 永久有效：
        - `PERSIST key`：移除指定 key 的过期时间，使其永久有效。
        - 在 `SET` 命令中不使用 `EX` 或 `PX` 选项，直接 `SET key value` 即可设置一个永不过期的 key。
30. Redis回收使用的是什么算法？
    答：Redis 内存回收主要依赖于它的 **淘汰策略（Eviction Policy）**，而不是传统意义上的垃圾回收（GC）。当 Redis 实例的内存使用达到 `maxmemory` 限制时，会根据配置的淘汰策略来决定删除哪些 key 以释放内存。常见的淘汰策略包括：
    - `noeviction`（默认）：不淘汰任何 key，当内存不足时，对于写操作（如 SET）直接返回错误（除了 SAVE 命令）。
    - `volatile-ttl`：在设置了过期时间的 key 中，优先淘汰那些 TTL（Time To Live）值最小的 key（即最快要过期的）。
    - `volatile-random`：在设置了过期时间的 key 中，随机淘汰一部分 key。
    - `volatile-lru`：在设置了过期时间的 key 中，使用 LRU（Least Recently Used，最近最少使用）算法淘汰最近最少被访问的 key。
    - `volatile-lfu`：在设置了过期时间的 key 中，使用 LFU（Least Frequently Used，最近最不常用）算法淘汰访问频率最低的 key。
    - `allkeys-lru`：在所有的 key 中（无论是否设置了过期时间），使用 LRU 算法淘汰 key。
    - `allkeys-random`：在所有的 key 中，随机淘汰一部分 key。
    - `allkeys-lfu`：在所有的 key 中，使用 LFU 算法淘汰 key。
      Redis 还会定期清理已经过期但尚未被删除的 key（通过 `expireIfNeeded` 函数在访问 key 或执行 `SAVE`/`BGSAVE` 时检查）。
31. 一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？
    答：
    - 一个 Redis 实例理论上最多可以存储约 **2^32 个 key**（即大约 42 亿个 key）。这受限于 Redis 内部哈希表的大小和系统内存。实际上，能存储多少 key 主要取决于服务器的内存大小和配置。
    - 对于 `List`（列表）、`Set`（集合）、`Sorted Set`（有序集合）这些数据结构：
        - 理论上，它们的元素数量也可以达到非常大的值，主要受限于可用内存。
        - `List`：基于双向链表或压缩列表（ziplist）实现，元素数量可以达到数亿甚至更多，具体取决于内存。
        - `Set`：基于哈希表或整数集合（intset）实现，元素数量同样可以达到数亿。
        - `Sorted Set`：基于压缩列表（ziplist）或跳跃表（skiplist）实现，元素数量也可以达到数亿。
          实际能存储多少元素，同样由服务器的内存总量和 Redis 的内存淘汰策略决定。当内存不足时，会根据淘汰策略删除部分元素或 key。
32. Redis—跳跃表，复杂度是多少？
    答：Redis 中的跳跃表（Skip List）是一种实现有序集合（Sorted Set）的数据结构。它的平均时间复杂度为：
    - **查找（Find/Search）**：O(log n)
    - **插入（Insert）**：O(log n)
    - **删除（Delete）**：O(log n)
      其中 n 是跳跃表中的元素数量。最坏情况下时间复杂度为 O(n)，但这种情况发生的概率极低，因为跳跃表通过随机生成索引层来保证平均性能。空间复杂度大约是 O(n log n)，因为每个节点除了存储数据外，还需要存储指向不同层级的指针。
33. Redis有哪些优缺点？为什么要用 Redis ？
    答：
    **优点**：
    - **高性能**：基于内存操作，读写速度极快（通常在微秒级别）。
    - **数据结构丰富**：支持字符串、哈希、列表、集合、有序集合等多种数据结构，满足不同场景需求。
    - **持久化**：支持 RDB（快照）和 AOF（追加日志）两种持久化方式，可以在重启后恢复数据。
    - **原子性操作**：支持对多个操作进行原子性处理（通过事务或特殊命令如 INCR）。
    - **发布/订阅**：内置消息发布订阅功能。
    - **灵活的数据过期**：支持设置 key 的过期时间。
    - **主从复制**：支持数据备份和读写分离。
    - **集群支持**：支持分布式部署，解决单机内存瓶颈。
    **缺点**：
    - **内存存储**：数据全部在内存中，内存成本较高，不适合存储海量数据。
    - **持久化可能丢失数据**：即使有 AOF，在极端情况下（如断电且 AOF 未刷盘）仍可能丢失少量数据。RDB 则可能丢失上次快照到崩溃之间的数据。
    - **内存限制**：受限于物理内存大小。
    - **复杂性**：对于复杂的应用场景，配置和维护可能比较复杂（如集群管理、持久化策略选择）。
    - **网络依赖**：作为客户端-服务器模型，网络延迟会影响性能。
    **为什么要用 Redis**：
    主要是因为它的 **高性能** 和 **丰富的数据结构**。当应用需要：
    - **缓存**：减轻数据库压力，加速数据访问。
    - **会话管理**：存储用户会话信息。
    - **实时统计**：如排行榜、计数器、用户在线状态等。
    - **消息队列**：实现简单的异步处理或任务队列（虽然专业消息队列如 Kafka/RabbitMQ 更强大）。
    - **分布式锁**：在分布式环境中协调多个进程。
    - **地理空间索引**：Redis 3.2+ 提供了 GEO 相关命令。
    这些场景下，Redis 的内存特性和数据结构优势可以带来显著的性能提升和开发便利性。
34. 为什么要用Redis 而不用 map/guava 做缓存?
    答：
    - **作用域不同**：
        - `Map` 和 Guava Cache 是 **本地缓存**，数据只存在于当前 JVM 进程内存中。如果应用部署在多台服务器上，每台服务器都有自己的缓存副本，无法共享数据，也无法实现分布式缓存。
        - Redis 是 **分布式缓存**，数据存储在独立的 Redis 服务器上，可以被多个应用实例共享访问。
    - **生命周期和一致性**：
        - Guava Cache 可以设置过期时间和大小限制，相对 `Map` 更好管理，但仍然是进程内的。应用重启或服务器宕机会导致缓存丢失。
        - Redis 可以持久化数据到磁盘，重启后能恢复。并且可以精确控制 key 的过期时间。
    - **功能丰富性**：
        - Redis 提供了 `Map` 和 Guava Cache 没有的丰富数据结构（如 List, Set, Sorted Set, Hash）和原子操作，可以满足更复杂的需求。
    - **集群和高可用**：
        - Redis 支持主从复制和集群，可以构建高可用、高性能的缓存系统，处理大量并发请求和大数据量。Guava Cache 无法做到。
    - **运维和管理**：
        - Redis 是一个独立的服务，可以单独进行监控、管理、备份和扩展。Guava Cache 需要与应用程序生命周期绑定。
          **总结**：如果只需要在单机应用内缓存数据，且对数据共享、持久化、高可用性要求不高，Guava Cache 是个不错的选择。但如果需要跨多台服务器共享缓存、需要更高的性能和可靠性、或者需要使用 Redis 特有的数据结构和功能，那么 Redis 是更合适的选择。
35. 如何用 Redis 统计独立用户访问量？
    答：可以使用 Redis 的 `Set` 数据结构来统计独立用户（Unique Users, UV）访问量。Set 的特点是元素唯一，自动去重。
    具体步骤如下：
    1.  **定义 Key**：为每天的独立用户统计定义一个唯一的 Key，例如 `unique_visitors:2025-06-25`。
    2.  **记录用户访问**：当有用户访问时，将用户的唯一标识（如用户 ID、Session ID 或设备 ID）作为元素，使用 `SADD` 命令添加到对应的 Set 中。
        ```redis
        SADD unique_visitors:2025-06-25 user123
        SADD unique_visitors:2025-06-25 user456
        SADD unique_visitors:2025-06-25 user123  // 重复添加，Set 会自动去重
        ```
    3.  **统计独立用户数**：使用 `SCARD` 命令获取 Set 中元素的数量，这个数量就是当天的独立用户访问量。
        ```redis
        SCARD unique_visitors:2025-06-25  // 假设返回 2，表示有 2 个独立用户
        ```
    4.  **设置过期时间**：为了避免 Set 永远增长占用过多内存，可以为这个 Key 设置一个合理的过期时间，比如第二天自动过期。
        ```redis
        EXPIRE unique_visitors:2025-06-25 86400  // 24小时后过期
        ```
    这种方法利用了 Set 的去重特性，简单高效。对于需要统计特定时间段（如最近7天）的独立用户，可以维护多个 Set（每天一个）并使用 `SUNION` 合并后再统计，或者使用 Redis 的 HyperLogLog 结构进行近似统计（内存占用更小，但结果不是精确值）。
36. 如何选择合适的持久化方式？
    答：选择 Redis 持久化方式主要取决于你的业务需求，特别是对数据安全性和性能的要求。主要有两种持久化方式：RDB（Redis Database）和 AOF（Append Only File）。
*   **RDB (Redis Database):**
    *   **原理:** 定期将内存中的数据集快照保存到磁盘（生成 .rdb 文件）。
    *   **优点:**
        *   生成紧凑的单文件，适合备份和迁移。
        *   保存的是某个时间点的数据状态，恢复速度快。
        *   对性能影响较小，尤其是在数据量大的情况下。
    *   **缺点:**
        *   两次快照之间如果 Redis 宕机，会丢失这段时间的数据。
        *   生成快照时可能会阻塞主线程（取决于配置和 Redis 版本，新版本有改进）。
    *   **适用场景:**
        *   对数据丢失不敏感，可以接受几分钟到几小时的数据丢失。
        *   需要定期备份。
        *   需要快速恢复数据。
*   **AOF (Append Only File):**
    *   **原理:** 记录服务器接收到的每一个写操作命令，在服务器启动时，通过重新执行这些命令来恢复数据。
    *   **优点:**
        *   数据更安全，可以根据 `appendfsync` 配置实现每秒同步或每次写入同步，最多丢失 1 秒或 0 秒的数据。
        *   即使 Redis 宕机，也只会丢失少量数据（取决于同步频率）。
    *   **缺点:**
        *   AOF 文件通常比 RDB 文件大。
        *   恢复数据通常比 RDB 慢。
        *   对性能有一定影响，尤其是在高频写入和 `appendfsync always` 配置下。
    *   **适用场景:**
        *   对数据安全性要求极高，不能容忍大量数据丢失。
        *   可以接受稍慢的恢复速度和稍高的性能开销。
*   **如何选择:**
    *   **优先考虑 AOF:** 如果你的应用不能承受任何数据丢失，AOF 是更好的选择。通常推荐 `appendfsync everysec` 平衡安全性和性能。
    *   **优先考虑 RDB:** 如果你能接受几分钟到几小时的数据丢失，并且更看重备份和恢复速度，RDB 是不错的选择。
    *   **混合使用 (RDB + AOF):** 这是目前推荐的配置。结合两者的优点：使用 AOF 保证数据安全性（设置 `appendfsync everysec`），同时定期使用 RDB 进行快照备份。Redis 重启时会优先加载 AOF 文件恢复更完整的数据。
37. Redis持久化数据和缓存怎么做扩容？
    答：Redis 的扩容涉及到两个方面：持久化数据的扩容和作为缓存时的扩容。它们的方法有所不同。
*   **持久化数据的扩容 (通常指数据量增长导致磁盘空间不足):**
    *   **监控和规划:** 定期监控磁盘使用情况，预估数据增长趋势。
    *   **增加磁盘空间:** 最直接的方法是给运行 Redis 的服务器增加磁盘容量（物理磁盘或云盘）。
    *   **优化持久化策略:**
        *   如果使用 RDB，可以调整 `save` 配置，减少快照频率，降低 RDB 文件大小。
        *   如果使用 AOF，可以定期执行 `BGREWRITEAOF` 命令，压缩 AOF 文件大小。
    *   **数据归档/冷热分离:** 将不常用的历史数据迁移到其他存储系统（如对象存储、归档数据库），只保留近期活跃数据在 Redis 中持久化。
    *   **使用 SSD:** 如果条件允许，使用 SSD 替代 HDD 可以提高持久化性能，并可能允许更高的写入负载。
*   **作为缓存时的扩容 (通常指需要服务更多的请求或更大的缓存容量):**
    *   **垂直扩容 (Scale-up):** 增加单台 Redis 实例的内存和 CPU 资源。但这有物理或成本上限。
    *   **水平扩容 (Scale-out):** 这是更常用的方法，通过增加 Redis 实例数量来分担负载和存储。主要方式有两种：
        *   **主从复制 + 分片 (如 Redis Cluster):**
            *   **主从复制:** 设置多个从节点，分担读压力，并作为主节点故障时的备份。但这不直接增加总缓存容量。
            *   **Redis Cluster:** 将数据分片（Shard）存储到多个 Redis 节点。每个节点负责一部分数据。客户端或代理（如 Codis、Twemproxy）将请求路由到正确的节点。这是实现大规模缓存水平扩容的标准方案。扩容时，可以添加新的节点，然后通过resharding将部分槽位（slots）迁移到新节点。
        *   **代理分片:** 使用代理服务器（如 Codis, Twemproxy）将客户端请求分发到后端的多个 Redis 实例。代理负责路由逻辑。扩容时，增加后端 Redis 实例并配置到代理。
            扩容过程通常需要考虑数据迁移、服务中断时间、客户端兼容性等问题，尤其是对于在线服务。
38. Redis key的过期时间和永久有效分别怎么设置？
    答：这个问题和第 29 题重复了，请参考第 29 题的答案。
39. 我们知道通过expire来设置key 的过期时间，那么对过期的数据怎么处理呢?
    答：当 Redis 中一个 Key 的过期时间到达后，这个 Key 会被标记为过期，但它的删除并不是立即发生的。Redis 采取了惰性删除和定期删除两种策略来处理过期的 Key，具体请看下一题。处理过程大致如下：
1.  **标记过期:** 当你使用 `EXPIRE`、`SETEX`、`LPUSH` 带过期时间等命令设置 Key 的过期时间时，Redis 内部会为这个 Key 记录一个过期时间戳。
2.  **等待删除:** Key 到期后，它并不会立刻从内存中移除。它仍然可以被读取（读取到的可能是旧值，然后该 Key 会被删除），也可以被更新（这通常会清除它的过期标记，使其变为永久有效）。
3.  **最终删除:** 最终，通过惰性删除或定期删除机制，这个过期的 Key 会被发现并从内存中删除，释放内存空间。
40. Redis的过期键的删除策略
    答：Redis 使用两种主要的策略来删除过期的 Key：
*   **惰性删除 (Lazy Deletion):**
    *   **原理:** 不主动删除过期的 Key。只有当客户端尝试访问（读取、写入等）一个已经过期的 Key 时，Redis 才会检查该 Key 是否过期，如果过期，就立即删除它。
    *   **优点:** 对性能影响小，只有在需要时才做删除操作。
    *   **缺点:** 如果一个 Key 过期了但长期不再被访问，它会一直留在内存中，直到被访问时才被删除，这可能导致内存泄漏（虽然不是真正的内存泄漏，但会浪费内存）。
*   **定期删除 (Periodic Deletion / Active Expiration):**
    *   **原理:** Redis 会每隔一段时间（由 `hz` 配置项控制，默认 10Hz）主动检查一次数据库中的一部分过期的 Key，并删除它们。每次检查会处理一定数量的 Key（算法内部优化）。
    *   **优点:** 可以主动清理过期的 Key，避免内存浪费。通过控制检查的频率和范围，可以平衡 CPU 使用率和内存使用率。
    *   **缺点:** 如果数据库中有很多过期的 Key，定期删除可能会消耗较多的 CPU 资源，影响 Redis 的响应速度。因此，Redis 限制了每次定期删除能处理的 Key 数量和执行时间。
*   **总结:** Redis 结合使用这两种策略：定期删除负责主动清理大部分过期的 Key，而惰性删除作为补充，确保那些未被定期删除机制处理到的过期 Key 在被访问时也能被清除。这种混合策略在保证内存及时释放和系统性能之间取得了较好的平衡。
41. Redis的内存用完了会发生什么？
    答：当 Redis 的内存使用达到 `maxmemory` 配置的限制时，会发生以下情况：
1.  **触发策略:** Redis 会根据配置的 `maxmemory-policy`（内存淘汰策略）来决定如何处理新数据的写入请求。
2.  **处理新写入:**
    *   **如果策略允许淘汰数据 (如 volatile-lru, allkeys-lru, volatile-random, allkeys-random, volatile-ttl):** Redis 会根据策略从现有数据中淘汰一部分 Key（例如，淘汰最近最少使用的 Key），然后为新数据分配空间。如果无法及时淘汰足够的数据，写入操作可能会失败（取决于配置，默认是返回错误）。
    *   **如果策略是 noeviction (不淘汰):** 这是默认策略。当内存满时，Redis 会拒绝所有写入操作（如 SET, LPUSH 等），并返回错误（`OOM command not allowed when used memory > 'maxmemory'`）。但读取操作（如 GET）仍然可以正常进行。
    *   **如果策略涉及过期键 (如 volatile-lru, volatile-random, volatile-ttl):** 只会淘汰设置了过期时间的 Key。
3.  **影响:**
    *   **写入失败:** 应用程序可能会收到写入失败的错误，需要处理这些异常。
    *   **数据丢失风险:** 如果使用 noeviction 策略，且应用没有处理写入失败，可能导致应该写入的数据丢失。
    *   **性能下降:** 即使没有直接拒绝写入，频繁的淘汰操作也可能影响 Redis 的性能。
4.  **避免方法:**
    *   合理设置 `maxmemory` 值，不要超过服务器可用内存。
    *   根据业务需求选择合适的 `maxmemory-policy`。
    *   优化数据结构，使用更节省内存的编码（如使用整数集合代替普通列表，使用压缩列表代替哈希表等）。
    *   进行水平扩容（如使用 Redis Cluster）。
42. Redis如何做内存优化？
    答：Redis 内存优化可以从多个方面入手：
*   **选择合适的数据结构:**
    *   根据场景选择最节省内存的数据结构。例如，用 `SET` 代替 `LIST` 存储唯一元素，用 `HASH` 存储对象属性。
*   **利用编码优化:**
    *   Redis 内部会根据数据量自动选择不同的底层编码方式。了解这些编码（如 ziplist, intset, hashtable 等）的特点，可以通过配置（如 `list-max-ziplist-size`, `hash-max-ziplist-entries` 等）来强制使用更节省内存的编码，前提是业务允许。
*   **使用更紧凑的数据类型:**
    *   尽量使用整数而不是字符串表示数值。
    *   使用短字符串。
*   **合理设置 Key 和 Value 的长度:**
    *   Key 尽量简短且具有可读性，避免过长无意义的 Key。
    *   Value 也应尽量紧凑，避免存储冗余信息。
*   **使用 Hash 结构存储对象:**
    *   对于包含多个属性的对象，使用 `HASH` 存储比用多个独立的 Key 存储更节省内存（Redis 内部有优化）。
*   **利用 Redis 4.0+ 的模块功能:**
    *   如 `RedisBloom` 模块提供的 `CMS` (Count-Min Sketch) 和 `TFT` (Top-K) 结构，可以在占用极小内存的情况下统计频率或 Top N，远比用普通数据结构（如 Sorted Set）节省内存。
*   **设置 Key 的过期时间:**
    *   对于临时数据，设置合理的过期时间，让 Redis 自动清理不再需要的数据，释放内存。
*   **选择合适的持久化策略:**
    *   AOF 文件通常比 RDB 大，如果对数据丢失不敏感，RDB 可能更节省磁盘空间。定期重写 AOF (`BGREWRITEAOF`) 也可以减小文件大小。
*   **使用 Redis Cluster:**
    *   水平分片可以将数据分散到多个节点，每个节点管理的数据量减少，可以更有效地利用内存。
43. Redis事务的三个阶段
    答：Redis 事务的执行过程可以分为以下三个阶段：
1.  **开始事务 (MULTI):**
    *   客户端向 Redis 发送 `MULTI` 命令。
    *   Redis 进入事务状态，之后客户端发送的所有命令都不会立即执行，而是被放入一个队列（命令队列）中。
2.  **执行命令队列 (QUEUED):**
    *   在事务状态下，客户端可以继续发送多个 Redis 命令（如 `SET`, `GET`, `INCR` 等）。
    *   对于每个命令，Redis 不会立即执行，而是返回 `QUEUED` 表示命令已入队。
3.  **执行事务 (EXEC):**
    *   客户端发送 `EXEC` 命令。
    *   Redis 开始按顺序执行命令队列中的所有命令。
    *   执行完成后，Redis 退出事务状态，并将所有命令的执行结果依次返回给客户端。
    *   如果在 `EXEC` 之前发送了 `DISCARD` 命令，则放弃执行队列中的所有命令，并退出事务状态。
        简单来说就是：`MULTI` -> `QUEUED` -> `EXEC`。
44. Redis事务相关命令
    答：Redis 事务相关的命令主要有以下几个：
*   **`MULTI`:** 标记一个事务块的开始。之后发送的命令都会被排队。
*   **`EXEC`:** 执行事务块中所有被排队的命令。这是事务的提交操作。
*   **`DISCARD`:** 取消事务，放弃执行事务块中所有被排队的命令。这是事务的回滚操作（放弃当前事务）。
*   **`WATCH key [key ...]`:** 监视一个或多个 Key。如果在 `EXEC` 执行之前，这些 Key 被其他客户端修改了，那么当前事务会以失败告终（`EXEC` 返回空回复）。常用于实现类似乐观锁的机制。
*   **`UNWATCH`:** 取消 `WATCH` 命令对所有 Key 的监视。如果在事务执行前调用，则清除所有监视，事务将不会因为 Key 被修改而失败。
45. Redis事务保证原子性吗，支持回滚吗？
    答：
*   **原子性:**
    *   Redis 事务**部分保证原子性**。它保证了队列中的命令要么都执行，要么都不执行（在 `EXEC` 命令成功执行的情况下）。也就是说，事务内的命令序列是作为一个整体执行的，不会被其他客户端的命令打断。
    *   **但是**，它不保证事务中的命令**不会因为错误而中断**。如果事务中的某个命令因为语法错误（比如命令写错了）而无法执行，那么在 `EXEC` 时，整个事务都会被取消，不会执行任何命令。但如果命令本身是正确的，只是因为运行时错误（比如对一个不存在的 Key 执行了某些操作）导致失败，其他命令仍然会继续执行。这与数据库的原子性（所有操作要么全部成功，要么全部失败，且失败时所有已执行的操作都要回滚）有所不同。
*   **回滚:**
    *   Redis 事务**不支持传统数据库意义上的回滚**。一旦某个命令在事务中执行失败了（不是因为语法错误导致整个事务取消），Redis 不会自动撤销之前已经执行成功的命令。它只会继续执行队列中剩余的命令。
    *   唯一的“回滚”机制是 `DISCARD` 命令，它可以放弃当前整个事务块，不执行任何命令。另外，如果被 `WATCH` 的 Key 在 `EXEC` 前被修改，事务也会失败（`EXEC` 返回空），但这并不是针对事务内命令执行错误的回滚。
        总结：Redis 事务提供了一种将多个命令打包执行的方式，保证了命令执行的顺序性和整体性（要么全执行，要么全不执行，除非有语法错误），但不保证每个命令执行成功的原子性，也不支持在命令执行失败后回滚整个事务。对于需要严格 ACID 特性的复杂操作，通常需要结合 Lua 脚本或其他外部机制来实现。
46. Redis事务支持隔离性吗？
    不支持。Redis 事务中的命令在执行前不会加锁，其他客户端可以并发执行命令，可能导致脏读或不可重复读。
47. Redis集群的主从复制模型是怎样的？
    主从复制模型是主从模式的，主节点负责处理写操作和读操作，从节点只负责复制主节点的数据，处理读操作。
48. 生产环境中的 redis 是怎么部署的？
    生产环境中通常采用 Redis 集群模式部署，包括主从复制和分片，以提高可用性和扩展性。
49. 说说Redis哈希槽的概念
    Redis 集群将整个数据集划分为 16384 个哈希槽，每个键根据其 CRC16 值对 16384 取模来确定属于哪个槽，槽再映射到具体节点。
50. Redis集群会有写操作丢失吗？为什么？
    会有。因为主节点通常采用异步复制方式将数据同步到从节点，如果主节点在数据同步完成前发生故障，可能导致部分写操作丢失。
51. Redis集群最大节点个数是多少？
    Redis集群最大节点个数是 1000 个。
52. Redis集群如何选择数据库？
    Redis集群不支持选择数据库，所有键都存储在同一个数据库中。
53. Redis是单线程的，如何提高多核CPU的利用率？
    可以通过在多核服务器上运行多个 Redis 实例来提高多核 CPU 的利用率。
54. 为什么要做Redis分区？有什么缺点？
    做分区是为了支持更大的数据集和更高的并发量。缺点包括：增加了系统复杂性，可能导致数据倾斜，以及跨分区操作效率降低。
55. 你知道有哪些Redis分区实现方案？
    常见的 Redis 分区实现方案包括：客户端分区、代理分区（如 Twemproxy）、以及 Redis 自身的集群模式。
56. 缓存的实现原理，设计缓存要注意什么
    实现原理：缓存通常位于应用与数据源（如数据库）之间，通过将频繁访问的数据或计算结果存储在内存中，以快速响应后续请求，减少对数据源的访问压力。设计上一般包括缓存键、缓存值、过期时间、缓存策略（如 LRU）等。
    设计注意：缓存穿透（频繁查询不存在的Key）、缓存雪崩（大量Key同时过期）、缓存击穿（热点Key失效瞬间大量请求打向数据源）、缓存与数据库一致性、Key设计、过期策略、容量规划、高可用等。
57. 如何解决 Redis 的并发竞争 Key 问题
    可以使用 Redis 的事务（MULTI/EXEC）或 Lua 脚本。Lua 脚本在 Redis 中是原子执行的，能更好地保证多个 Redis 操作作为一个整体不被打断。另一种方式是使用 SETNX（或 SET with NX option）配合重试机制实现简单的分布式锁。
58. 分布式Redis是前期做还是后期规模上来了再做好？为什么？
    建议前期就考虑并设计分布式 Redis 方案。因为从单机迁移到分布式涉及数据迁移、架构调整、客户端改造等复杂工作，后期规模上来再改造成本和风险会非常高。提前规划可以更好地支持业务增长，避免性能瓶颈。
59. 什么是 RedLock？
    RedLock 是一种分布式锁算法，旨在解决在多个 Redis 实例上实现更可靠、更安全的分布式锁的问题。它通过在多个独立的 Redis 实例上获取锁，并验证大多数实例是否成功获取锁来提高锁的安全性，防止单点故障或网络分区导致的锁失效。
60. Redis支持的Java客户端都有哪些？官方推荐用哪个？
    常见的 Java 客户端有 Jedis、Lettuce、Redisson 等。官方没有明确指定唯一推荐，但 Lettuce 和 Redisson 因其高性能、支持连接池、异步操作、反应式编程（Lettuce）以及高级特性（Redisson）而备受推荐。Lettuce 因其 Netty 底层和更好的连接管理和协议支持，在许多场景下是更现代的选择。
61. 为什么Redis的操作是原子性的，怎么保证原子性
    Redis 的单条命令是原子性的，因为它的命令执行模型是单线程的（处理命令的线程只有一个）。命令会顺序执行，一个命令执行完成前，不会执行下一个命令。事务（MULTI/EXEC）通过将多个命令打包，保证这些命令作为一个整体原子性地执行。Lua 脚本通过在 Redis 中被原子化执行来保证脚本内所有操作的原子性。
62. Redis常见性能问题和解决方案？
    常见问题：网络延迟、内存不足、CPU 瓶颈、大量 Key 过期导致 CPU 飙升、大 Key/Hot Key 问题、持久化影响性能等。
    解决方案：优化网络配置、合理规划内存（使用合适的数据结构、压缩、淘汰策略）、监控 CPU 使用、设置合理的 Key 过期策略、使用 SCAN 命令渐进式处理大 Key 集合、避免产生超大 Key、使用 Pipeline 减少 RTT、优化持久化配置（如 AOF 重写）、使用集群分散压力、监控热点 Key 并做缓存等。
63. 一个字符串类型的值能存储最大容量是多少？
    一个字符串类型的值最大可以存储 512 MB 的数据。
64. Redis如何做大量数据插入？
    可以使用 Redis 的管道（Pipeline）技术，将多个命令打包一次性发送给 Redis 服务器，减少网络往返时间（RTT）。对于非常大的数据集，可以考虑使用 Redis 的 RDB 快照原理，通过 `redis-cli --pipe` 或专门的导入工具（如 `redis-benchmark` 模拟，或自定义脚本配合 Pipeline）。
65. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
    可以使用 `SCAN` 命令配合通配符模式。例如，如果前缀是 `user:12345:history:`，可以执行 `SCAN cursor MATCH user:12345:history:* COUNT num`。`SCAN` 命令是渐进式的，可以避免像 `KEYS` 命令那样阻塞整个 Redis 服务器，`MATCH` 参数用于匹配特定模式的 Key，`COUNT` 参数建议设置一个较大的值（如 1000 或更高）来提高遍历效率。需要循环调用 `SCAN` 直到游标 `cursor` 返回 0。
66. 使用Redis做过异步队列吗，是如何实现的？
    可以使用 LPUSH 命令将任务推入列表，BRPOP 命令阻塞式地取出任务。
67. Redis如何实现延时队列？
    可以使用 ZSET，将任务和过期时间作为score，到期后通过 ZRANGEBYSCORE 取出。
68. Redis回收进程如何工作的？
    通过淘汰策略（如 LRU、TTL）在内存不足时自动删除部分键值对。
69. 热点数据和冷数据是什么
    热点数据是访问频率高的数据，冷数据是访问频率低的数据。
70. 使用过Redis哪些命令？
    如 SET、GET、DEL、LPUSH、RPUSH、LPOP、RPOP、LPUSHX、RPUSHX、EXPIRE、TTL、HSET、HGET、SADD、SREM、SMEMBERS、ZADD、ZRANGE、ZRANK、ZREM、SCAN 等。